<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gesture Training + Real-Time Gesture Prediction</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- External libraries -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js"></script>

<style>
    body { background:#161616; color:white; font-family:Arial; padding:20px; }
    #container { max-width:1100px; margin:auto; }
    button, select { padding:10px; margin:5px; font-size:16px; }
    canvas { background:#1f1f1f; border-radius:6px; margin-top:20px; }
    #threeContainer { width:100%; height:280px; margin-top:20px; border:1px solid #444; }
    #predictionBox {
        margin-top:20px;
        background:#222; padding:15px; border-radius:10px;
        box-shadow:0 0 10px #000 inset;
    }
    #confidenceBar {
        width:100%; height:16px; background:#444; border-radius:20px; margin-top:10px;
    }
    #confidenceFill {
        width:0%; height:100%; background:#00e676; border-radius:20px;
        transition: width 0.2s;
    }
    #gestureVisual {
        margin-top:20px; font-size:28px; text-align:center;
        height:60px; display:flex; justify-content:center; align-items:center;
    }

    /* Orientation lock overlay */
    #orientationLock {
        position: fixed;
        top: 0; left: 0;
        width: 100vw; height: 100vh;
        background: #000;
        color: white;
        display: none;
        justify-content: center;
        align-items: center;
        text-align: center;
        padding: 40px;
        z-index: 999999;
        font-size: 24px;
    }
</style>
</head>

<body>
<div id="container">

<h1>Gesture Training + Real-Time Gesture Prediction</h1>

<!-- Model choice -->
<label><strong>Model Architecture:</strong></label>
<select id="modelType">
    <option value="dense">Dense Neural Net</option>
    <option value="lstm">LSTM / CNN Sequence Model</option>
</select>

<!-- Gesture selector -->
<br><br>
<label><strong>Gesture:</strong></label>
<select id="gestureSelect"></select>
<button id="recordBtn">Record Gesture</button>

<br><br>
<!-- Dataset buttons -->
<button id="saveDatasetBtn">Download Dataset</button>
<button id="uploadDatasetBtn">Upload Dataset (JSON)</button>
<input type="file" id="uploadDatasetInput" accept=".json" style="display:none">

<br><br>
<!-- Model buttons -->
<button id="trainBtn">Train Model</button>
<button id="saveModelBtn">Download Model</button>
<button id="uploadModelBtn">Upload Model</button>
<input type="file" id="uploadModelInput" webkitdirectory directory style="display:none">

<br><br>

<!-- REAL-TIME PREDICTION DISPLAY -->
<div id="predictionBox">
    <h2>Real-Time Gesture Prediction</h2>
    <div><strong>Detected:</strong> <span id="predictedGesture">None</span></div>

    <div id="confidenceBar">
        <div id="confidenceFill"></div>
    </div>

    <!-- Visual animation -->
    <div id="gestureVisual"></div>
</div>
<br>

<h2>Real-Time Sensor Charts</h2>
<canvas id="accChart"></canvas>
<canvas id="gyroChart"></canvas>

<!-- 3D Phone Motion (optional) -->
<!-- <h2>3D Phone Motion</h2>
<div id="threeContainer"></div> -->

</div>

<!-- ORIENTATION LOCK OVERLAY -->
<div id="orientationLock">ðŸ“± Please rotate your device vertically.<br><br>Landscape mode is blocked.</div>

<script>
//--------------------------------------------------------------
// 1) GLOBALS
//--------------------------------------------------------------
let dataset = [];
let model = null;
let recording = false;
let recordBuffer = [];
const sequenceLength = 60;

// Example gestures
/*const gestures = [
    "idleState","verticalThrowState","horizontalThrowState",
    "shieldState","zSlashState","crossStrikeState"
];*/

// Example gestures
const gestures = [
    "idle","poke","pushback","verticalSlash","horizontalSlash","jump","pointSky","crouch","turn90clockwise","turn180clockwise","turn360clockwise","turn720clockwise","turn1080clockwise","turn90anticlockwise","turn180anticlockwise","turn360anticlockwise","turn720anticlockwise","turn1080anticlockwise",
    "shield","shake","bow","spiral","square","triangle","circle","pentagon","leanleft","leanright","leanforward","leanbackward",
	"A","B","C","D","E","F","G","H","I","J","K","L","M","N","P","Q","R","S","T","U","V","W","X","Y","Z","1","2","3","4","5","6","7","8","9"
];

const gestureSelect = document.getElementById("gestureSelect");
gestures.forEach(g=>{ let o=document.createElement("option"); o.value=o.textContent=g; gestureSelect.appendChild(o); });

let lastSensor = { ax:0, ay:0, az:0, gx:0, gy:0, gz:0 };

window.addEventListener("devicemotion", (e)=>{
    lastSensor.ax = e.acceleration.x||0;
    lastSensor.ay = e.acceleration.y||0;
    lastSensor.az = e.acceleration.z||0;
    lastSensor.gx = e.rotationRate.alpha||0;
    lastSensor.gy = e.rotationRate.beta||0;
    lastSensor.gz = e.rotationRate.gamma||0;

    updateCharts(lastSensor.ax,lastSensor.ay,lastSensor.az,lastSensor.gx,lastSensor.gy,lastSensor.gz);
    update3D(lastSensor.gx,lastSensor.gy,lastSensor.gz);

    if (recording) recordBuffer.push({...lastSensor});

    runPrediction();
});

//--------------------------------------------------------------
// 2) RECORDING
//--------------------------------------------------------------
document.getElementById("recordBtn").onclick = ()=>{
    const g = gestureSelect.value;
    if (!recording){
        recording=true;
        recordBuffer=[];
        document.getElementById("recordBtn").textContent="Stop Recording";
    } else {
        recording=false;
        document.getElementById("recordBtn").textContent="Record Gesture";
        if (recordBuffer.length>0){
            dataset.push({gesture:g,data:recordBuffer});
            alert(`Recorded ${recordBuffer.length} samples for ${g}`);
        }
    }
};

//--------------------------------------------------------------
// 3) DATASET LOAD/SAVE
//--------------------------------------------------------------
document.getElementById("saveDatasetBtn").onclick=()=>{
    const blob = new Blob([JSON.stringify(dataset)],{type:"application/json"});
    const a=document.createElement("a");
    a.href=URL.createObjectURL(blob);
    a.download="dataset.json";
    a.click();
};

document.getElementById("uploadDatasetBtn").onclick=()=>{
    document.getElementById("uploadDatasetInput").click();
};

document.getElementById("uploadDatasetInput").onchange=(e)=>{
    const f=e.target.files[0];
    const reader=new FileReader();
    reader.onload=()=>{
        dataset=JSON.parse(reader.result);
        alert("Dataset loaded.");
    };
    reader.readAsText(f);
};

//--------------------------------------------------------------
// 4) MODEL BUILDER
//--------------------------------------------------------------
function buildDense(num){
    const m=tf.sequential();
    m.add(tf.layers.dense({units:64,activation:"relu",inputShape:[6]}));
    m.add(tf.layers.dense({units:64,activation:"relu"}));
    m.add(tf.layers.dense({units:num,activation:"softmax"}));
    m.compile({optimizer:"adam",loss:"categoricalCrossentropy",metrics:["accuracy"]});
    return m;
}

function buildLSTM(num){
    const m=tf.sequential();
    m.add(tf.layers.lstm({units:64,inputShape:[sequenceLength,6]}));
    m.add(tf.layers.dense({units:num,activation:"softmax"}));
    m.compile({optimizer:"adam",loss:"categoricalCrossentropy",metrics:["accuracy"]});
    return m;
}

//--------------------------------------------------------------
// 5) TRAIN MODEL
//--------------------------------------------------------------
document.getElementById("trainBtn").onclick = async ()=>{
    if(dataset.length===0){alert("Dataset empty");return;}

    const type=document.getElementById("modelType").value;
    const num=gestures.length;

    model = (type==="dense") ? buildDense(num) : buildLSTM(num);

    const xs=[], ys=[];
    dataset.forEach(entry=>{
        const idx=gestures.indexOf(entry.gesture);
        if (type==="dense"){
            entry.data.forEach(s=>{
                xs.push([s.ax,s.ay,s.az,s.gx,s.gy,s.gz]);
                ys.push(idx);
            });
        } else {
            let seq = entry.data.slice(-sequenceLength);
            if (seq.length<sequenceLength) return;
            xs.push(seq.map(s=>[s.ax,s.ay,s.az,s.gx,s.gy,s.gz]));
            ys.push(idx);
        }
    });

    const xTensor = (type==="dense") ? tf.tensor2d(xs) : tf.tensor3d(xs);
    const yTensor = tf.oneHot(tf.tensor1d(ys,'int32'), num);

    await model.fit(xTensor, yTensor, {
        epochs:12, batchSize:32, shuffle:true,
        callbacks:{ onEpochEnd:(e,l)=>console.log("Epoch",e,l.loss,l.acc) }
    });

    alert("Training complete!");
    xTensor.dispose(); yTensor.dispose();
};

//--------------------------------------------------------------
// 6) MODEL SAVE/LOAD
//--------------------------------------------------------------
document.getElementById("saveModelBtn").onclick=()=>{
    if(model) model.save("downloads://gesture-model");
};

document.getElementById("uploadModelBtn").onclick=()=>{
    document.getElementById("uploadModelInput").click();
};

document.getElementById("uploadModelInput").onchange=async(e)=>{
    try{
        model=await tf.loadLayersModel(tf.io.browserFiles(e.target.files));
        alert("Model loaded!");
    } catch(err){
        alert("Error loading model.");
    }
};

//--------------------------------------------------------------
// 7) REAL-TIME PREDICTION
//--------------------------------------------------------------
let predictionBuffer = [];

async function runPrediction(){
    if (!model) return;

    const type=document.getElementById("modelType").value;
    predictionBuffer.push([...Object.values(lastSensor)]);
    if (predictionBuffer.length > sequenceLength)
        predictionBuffer.shift();

    let input;
    if (type==="dense"){
        input=tf.tensor2d([predictionBuffer[predictionBuffer.length-1]]);
    } else {
        if (predictionBuffer.length<sequenceLength) return;
        const seq = predictionBuffer.slice(-sequenceLength)
            .map(v=>[v[0],v[1],v[2],v[3],v[4],v[5]]);
        input=tf.tensor3d([seq]);
    }

    const pred=model.predict(input);
    const data=await pred.data();
    input.dispose(); pred.dispose();

    let maxIdx=0, maxVal=0;
    data.forEach((v,i)=>{ if(v>maxVal){maxVal=v; maxIdx=i;} });

    document.getElementById("predictedGesture").textContent=gestures[maxIdx];
    document.getElementById("confidenceFill").style.width=(maxVal*100)+"%";

    showGestureVisual(gestures[maxIdx], maxVal);
}

//--------------------------------------------------------------
// 8) VISUAL ANIMATION
//--------------------------------------------------------------
function showGestureVisual(gesture, conf){
    const el=document.getElementById("gestureVisual");
    if (conf<0.50){ el.textContent=""; return; }

    el.textContent = gesture.replace(/State/g,"")
                            .replace(/([A-Z])/g," $1")
                            .trim();

    el.style.transform="scale(1.3)";
    setTimeout(()=> el.style.transform="scale(1)",150);
}

//--------------------------------------------------------------
// 9) CHARTS
//--------------------------------------------------------------
let accChart, gyroChart;
function initCharts(){
    accChart=new Chart(document.getElementById("accChart"),{
        type:"line",
        data:{labels:[],datasets:[
            {label:"Ax",data:[]},{label:"Ay",data:[]},{label:"Az",data:[]}
        ]},options:{animation:false}
    });
    gyroChart=new Chart(document.getElementById("gyroChart"),{
        type:"line",
        data:{labels:[],datasets:[
            {label:"GÎ±",data:[]},{label:"GÎ²",data:[]},{label:"GÎ³",data:[]}
        ]},options:{animation:false}
    });
}
function updateCharts(ax,ay,az,gx,gy,gz){
    const upd=(chart,vals)=>{
        chart.data.labels.push("");
        chart.data.datasets.forEach((ds,i)=>ds.data.push(vals[i]));
        if(chart.data.labels.length>40){
            chart.data.labels.shift();
            chart.data.datasets.forEach(ds=>ds.data.shift());
        }
        chart.update();
    };
    upd(accChart,[ax,ay,az]);
    upd(gyroChart,[gx,gy,gz]);
}

//--------------------------------------------------------------
// 10) 3D PHONE VISUALIZATION
//--------------------------------------------------------------
let scene, camera, renderer, phoneMesh;
function init3D(){
    scene=new THREE.Scene();
    camera=new THREE.PerspectiveCamera(60,1.8,0.1,100);
    camera.position.z=3;

    renderer=new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth*0.7,280);
    document.getElementById("threeContainer").appendChild(renderer.domElement);

    const geo=new THREE.BoxGeometry(1,2,0.1);
    const mat=new THREE.MeshNormalMaterial();
    phoneMesh=new THREE.Mesh(geo,mat);
    scene.add(phoneMesh);

    const animate=()=>{ requestAnimationFrame(animate); renderer.render(scene,camera); };
    animate();
}
function update3D(gx,gy,gz){
    if (!phoneMesh) return;
    phoneMesh.rotation.x+=gx*0.0005;
    phoneMesh.rotation.y+=gy*0.0005;
    phoneMesh.rotation.z+=gz*0.0005;
}

//--------------------------------------------------------------
// INIT
//--------------------------------------------------------------
initCharts();
//init3D();

</script>

<!-- ORIENTATION LOCK LOGIC -->
<script>
function isMobileDevice() {
    const ua = navigator.userAgent || navigator.vendor || window.opera;

    if (/android|iphone|ipad|ipod|mobile|tablet|touch/i.test(ua)) return true;

    if (navigator.maxTouchPoints && navigator.maxTouchPoints > 1) return true;

    return false;
}

function checkOrientation() {
    const lock = document.getElementById("orientationLock");

    // Desktop: no lock
    if (!isMobileDevice()) {
        lock.style.display = "none";
        document.body.style.overflow = "auto";
        return;
    }

    const isLandscape = window.innerWidth > window.innerHeight;

    if (isLandscape) {
        lock.style.display = "flex";
        document.body.style.overflow = "hidden";
    } else {
        lock.style.display = "none";
        document.body.style.overflow = "auto";
    }
}

let orientationTimeout = null;
function checkOrientationDebounced() {
    clearTimeout(orientationTimeout);
    orientationTimeout = setTimeout(checkOrientation, 150);
}

window.addEventListener("orientationchange", checkOrientationDebounced);
window.addEventListener("resize", checkOrientationDebounced);

// Initial check
checkOrientation();
</script>

</body>
</html>
